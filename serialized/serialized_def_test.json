["        XComponentContext xContext = new ComponentContext(context_entries, null);", "                if (pair.startsWith(\"url=\")) {", "                panel.setNonUndoableChange(false);", "public class EntryAddedEvent extends EntryEvent {", "        library.getItems().addAll(", "public class EntryRemovedEvent extends EntryEvent {", "        metaData.getUserFileDirectory(preferences.getUser())", "public class BibDatabase {", "    private BibEntry entry;  // A reference to the entry this editor works on.", "public abstract class AbstractBibtexKeyPattern {", "        Button buttonOptionSelectAll = new Button();", "        target.addChild((T) this, targetIndex);", "    public void addPossibleSuggestions(@SuppressWarnings(\"unchecked\") T... newPossible) {", "                fieldChanges.add(new FieldChangeViewModel(field, memEntry, tmpEntry, mem.orElse(null), tmp.orElse(null), disk.orElse(null)));", "    public void subscribeToDescendantChanged(Consumer<T> subscriber) {", "            entries = frame.getCurrentBasePanel().getDatabase().getEntries();", "        boolean okEnabled = !nameField.getText().trim().isEmpty();", "        BackgroundTask.wrap(this::pushEntries)", "                            LOGGER.debug(\"Mode MOVE\"); //alt on win", "public class PushToApplicationAction extends SimpleCommand {", "public enum BibDatabaseMode {", "public interface TaskExecutor {", "        new ViewModelTreeTableCellFactory<GroupNodeViewModel>()", "            for (Field field : FIELDS) {", "public class AppendDatabaseDialog extends BaseDialog<Boolean> {", "    public static final XComponentContext defaultBootstrap_InitialComponentContext(String ini_file, Hashtable<String, String> bootstrap_parameters) throws Exception {", "public interface BaseAction {", "    public static <A, B> void bindBidirectional(ObservableValue<A> propertyA, ObservableValue<B> propertyB, Consumer<B> updateA, Consumer<A> updateB) {", "    public static <A> void bindBidirectional(Property<A> propertyA, ObservableValue<A> propertyB, Consumer<A> updateB) {", "public class Bootstrap {", "                    return null; // can not use BackgroundTask.wrap(Runnable) because Runnable.run() can't throw exceptions", "    public static boolean checkKeyCombinationEquality(KeyCombination combination, KeyEvent keyEvent) {", "            if (UnoRuntime.queryInterface(XFootnote.class, range.getText()) != null) {", "        if (layoutFile.get().isEmpty() || name.get().isEmpty() || extension.get().isEmpty()", "        for (Field field : differentFields) {", "                String oldDefault = mainPrefsNode.get(\"defaultLabelPattern\", null);", "    private boolean isDuplicateCiteKeyExisting(String citeKey) {", "public class ParserResultWarningDialog {", "@SuppressWarnings(\"unused\") // class is indirectly constructed by log4j", "    List<FieldChange> cleanup(BibEntry entry);", "            clip.setHeight(computePrefHeight(this.getWidth()));", "public class RankingFieldComparator implements Comparator<Optional<SpecialFieldValueViewModel>> {", "                if ((pages[0] != null) || (pages[1] != null)) {", "    public TreeNode(Class<T> derivingClass) {", "            if (previousLine == null) {", "    private int convertAccented(char[] c, int start, String s, StringBuilder sb, FORMAT_MODE format) {", "public class ConvertLegacyExplicitGroups implements PostOpenMigration {", "public class ConvertMarkingToGroups implements PostOpenMigration {", "                        newRes.append(res, next, stringEnd + 1);", "            XUnoUrlResolver xUrlResolver = UnoUrlResolver.create(xLocalContext);", "        Object desktop;", "    private TableColumn<BibEntryTableViewModel, List<LinkedFile>> createExtraFileColumn(String externalFileTypeName) {", "    public abstract T copyNode();", "            colorField.setValue(IconTheme.getDefaultGroupColor());", "        DATE_PICKER(MaterialDesignIcon.CALENDAR), /* css: calendar */", "        READ_STATUS_SKIMMED(Color.ORANGE, MaterialDesignIcon.EYE), /*css: eye */", "        WRITE_XMP(MaterialDesignIcon.IMPORT), /* css: import */", "        REQUIRED(MaterialDesignIcon.LABEL), /*css: label */", "        CASE_SENSITIVE(MaterialDesignIcon.ALPHABETICAL), /* css: mdi-alphabetical */", "                        LOGGER.debug(\"Mode COPY\");", "            return new SimpleEditor(field, suggestionProvider, fieldCheckers, preferences, isSingleLine);", "        ScrollPane descriptionPane = new ScrollPane(descriptionTextFlow);", "public class DuplicationChecker {", "        }", "        Optional<DOI> doi = entry.getField(StandardField.DOI).flatMap(DOI::parse);", "            linkedFile.edit();", "        private final char asChar;", "            comparators.add(new IdComparator());", "            return Collections.emptySortedSet();", "                    if (!sb.toString().trim().isEmpty()) {", "    AuxParserResult parse(Path auxFile);", "                prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, true);", "            return BibDatabaseMode.BIBTEX;", "    private static final List<Field> FIELDS = Arrays.asList(StandardField.NOTE, StandardField.URL, new UnknownField(\"ee\"));", "            NATIVE_DESKTOP.openFile(filePath, \"\");", "        setupClearButtonField(searchField);", "    public synchronized Optional<BibEntry> getEntryById(String id) {", "        List<String> filenames = new ArrayList<>();", "        TITLE_LOWERS('t'),", "        if (entry.hasField(StandardField.DOI)) {", "        this.getChildren().clear();", "        String[] citMarkers = new String[names.size()];", "            LOGGER.info(\"Using css from VM option: \" + cssVmArgument);", "        Map<String, BibtexString> remaining = new HashMap<>();", "    private final TextFlow descriptionTextFlow = new TextFlow();", "    private final TextField keywordGroupSearchTerm = new TextField();", "public class DoiCleanup implements CleanupJob {", "    public Collection<BibtexString> getUsedStrings(Collection<BibEntry> entries) {", "    public Optional<T> getDescendant(List<Integer> indexedPath) {", "    public List<Integer> getIndexedPathFromRoot() {", "    public ObservableList<T> getChildren() {", "    private ScrollPane getErrorInfo() {", "    private int braceLevel;", "        new ViewModelTreeTableCellFactory<GroupNodeViewModel>()", "        TABLE_ICONS.put(StandardField.FOLDER, icon);", "        TABLE_ICONS.put(StandardField.DOI, icon);", "        TABLE_ICONS.put(StandardField.PS, icon);", "                if (entry.isPresent()) {", "                field.getValues().size() == 1,", "        if (Globals.prefs.get(JabRefPreferences.EXTERNAL_FILE_TYPES, null) == null) {", "        if (modifiers.isEmpty()) {", "    private String resolveString(String label, Set<String> usedIds, Set<String> allUsedIds) {", "        if (!isBlank && Globals.prefs.getBoolean(JabRefPreferences.OPEN_LAST_EDITED)) {", "            int index = link.lastIndexOf('.');", "        Optional<File> databaseFile = getDatabaseFile();", "                if (style.isFormatCitations()) {", "        if (style.isSortByPosition()) {", "            XMultiComponentFactory xLocalServiceManager = xLocalContext.getServiceManager();", "        insertBasicFactories(xSet, xImpLoader);", "            String bName = getUniqueReferenceMarkName(keyString,", "        xSet.insert(xImpLoader.activate(\"com.sun.star.comp.bridgefactory.BridgeFactory\", null, null, null));", "        xSet.insert(xImpLoader.activate(\"com.sun.star.comp.urlresolver.UrlResolver\", null, null, null));", "    public synchronized void addString(BibtexString string) throws KeyCollisionException {", "    protected static ClipboardContent processXslFo(List<String> citations) {", "    public synchronized boolean insertEntry(BibEntry entry) throws KeyCollisionException {", "    protected static ClipboardContent processText(List<String> citations) {", "        subtreeRoot.removeAllChildren();", "                sb.deleteCharAt(sb.length() - 1); // Kill backslash", "            String issueDetails = \"<details>\\n\" + \"<summary>\" + \"Detail information:\" + \"</summary>\\n\\n```\\n\"", "    public List<String> getFileDirectories(Field field, FilePreferences preferences) {", "    private Multimap<String, BibEntry> getMarkingWithEntries(List<BibEntry> entries) {", "        DefaultTaskExecutor.runInJavaFXThread(() -> {", "    public void hide(SidePaneType type) {", "                    originalEntry.setField(field, mergedString.get()); // mergedString always present", "    private static void upgradePrefsToOrgJabRef(Preferences mainPrefsNode) {", "        if (mainPrefsNode.get(JabRefPreferences.IMPORT_FILENAMEPATTERN, null) != null) {", "    private static void upgradeLabelPatternToBibtexKeyPattern(JabRefPreferences prefs) {", "            if (mainPrefsNode.nodeExists(\"logic/labelpattern\")) {", "public class AutosaveEvent {", "public class BibDatabaseContextChangedEvent {", "            throw new NoDocumentException(\"No Writer documents found\");", "            } else if (mainPrefsNode.nodeExists(\"labelPattern\")) { // node used for version <3.0", "            } else if (mainPrefsNode.nodeExists(\"logic/labelPattern\")) { // node used for version 3.0-3.2", "        return AuthorList.fixAuthorLastNameFirstCommas(nameToFormat, abbrAuthorNames, false);", "                command = command.replaceAll(\"\\\\s+\", \" \"); // normalize white spaces", "            return;", "        String[][] array = new String[types.size() + defTypes.size()][];", "        if (!result.getToRemove().isEmpty()) {", "            FieldChangedEvent fieldChange = (FieldChangedEvent) event;", "    public static boolean openExternalFileAnyFormat(final BibDatabaseContext databaseContext, String link,", "    public BasePanel openNewSharedDatabaseTab(DBMSConnectionProperties dbmsConnectionProperties)", "                    ce.addEdit(new UndoableFieldChange(originalEntry, field, originalString.get(), null)); // originalString always present", "public class ImportCommand extends SimpleCommand {", "        if (preamble != null) {", "                    connection.userAgent(URLDownload.USER_AGENT);", "public class EditorMenus {", "                Dragboard dragboard = treeTable.startDragAndDrop(TransferMode.MOVE);", "        return \"(%252B\" + query.trim().replaceAll(\"\\\\s+\", \"%20%252B\") + \")\";", "    public int getCrossRefEntriesCount() {", "    public static List<BibEntry> purgeEmptyEntries(Collection<BibEntry> entries) {", "        if (compound.hasEdits()) {", "        for (FieldChange change : changes) {", "                autoRemoveExactDuplicates.set(true); // Remember choice", "        List<String> result = new ArrayList<>();", "            row.setDisclosureNode(null);", "                    uniqPath = uniqPath.substring(0, uniqPath.lastIndexOf(File.separator));", "            items.remove(0); // Remove separator", "    public void removeChild(T child) {", "    public synchronized void removeEntry(BibEntry toBeDeleted, EntryEventSource eventSource) {", "    public void moveTo(T target) {", "    public void moveTo(T target) {", "@SuppressWarnings(\"unchecked\") // We use some explicit casts of the form \"(T) this\". The constructor ensures that this cast is valid.", "@SuppressWarnings(\"unchecked\") public abstract class TreeNode<T extends TreeNode<T>> {", "public class BibDatabaseContext {", "    public void setExternalFileTypes(List<ExternalFileType> types) {", "        if (Globals.prefs.getBoolean(JabRefPreferences.WINDOW_MAXIMISED)) {", "    class DuplicateSearchResult {", "        return Optional.of(new UnknownExternalFileType(name));", "    default double getWeight() { return 1; }", "    public static BibDatabaseMode parse(String data) {", "    public Optional<T> getChildAt(int index) {", "    public synchronized Optional<BibEntry> getEntryByKey(String key) {", "    public synchronized List<BibEntry> getEntriesSorted(Comparator<BibEntry> comparator) {", "    public int getNumberOfChildren() {", "    public int getEntryCount() {", "    public int getNumberOfKeyOccurrences(String citeKey) {", "    public int getStringCount() {", "    public T getRoot() {", "    public Optional<T> getLastChild() {", "    public boolean isAncestorOf(T anotherNode) {", "            base.addString(string);", "        if (!filesToOpen.isEmpty()) {", "                    Elements elements = html.body().select(\"a[href]\");", "                int onSelectedDelta = 0;", "                    if (removed == initialCount) {", "public class SendAsEMailAction implements BaseAction {", "                    xViewCursor.goLeft((short) 1, true);", "        } else if (panel.getBibDatabaseContext().getLocation() == DatabaseLocation.SHARED) {", "                        LOGGER.debug(\"Mode COPY\");", "    String getTabName();", "            BibEntry firstNewEntry = entriesToAdd.get(0);", "    public GroupDialog(DialogService dialogService, BasePanel basePanel, JabRefPreferences prefs, AbstractGroup editedGroup) {", "                mainPrefsNode.nodeExists(JabRefPreferences.CUSTOMIZED_BIBLATEX_TYPES)) {", "                LOGGER.debug(\"New prefs node already exists with content - skipping migration\");", "    private final SortedMap<KeyBinding, String> bindings;", "        BindingsHelper.bindContentBidirectional(entry.getFieldsObservable(), codeArea.focusedProperty(), onFocus -> {", "        BibEntry one = selectedEntries.get(0);", "                    String newVal = FileFieldWriter.getStringRepresentation(linkedFile);", "        for (BibtexString original : notMatched) {", "        @SuppressWarnings(\"unchecked\")", "    public List<BibEntry> resolveForStrings(Collection<BibEntry> entriesToResolve, boolean inPlace) {", "    private void tearDownJabRef(List<String> filenames) {", "        if (result == null) {", "        EasyBind.subscribe(tabbedPane.getSelectionModel().selectedItemProperty(), tab -> {", "public abstract class Formatter {", "                if ((directory != null) && !Files.exists(directory)) {", "    public void append(LogEvent event) {", "    public void openAction(String filePath) {", "            BibtexString bs = new BibtexString(disk, content);", "            while (preferences.hasKey(JabRefPreferences.CUSTOM_TAB_NAME + i)) {", "            for (Map.Entry<Field, String> field : newEntry.getFieldMap().entrySet()) {", "public class TextInputControlBehavior {", "public class FieldChange {", "public class UndoableKeyChange extends AbstractUndoableJabRefEdit {", "public class KeyBindingViewModel {", "public class BibDatabaseContextChangedEvent {", "                importError = e;", "    private static class SuggestionProviderString<T> extends SuggestionProvider<T> {", "            }", "    public List<String> getDefaultValue() {", "    boolean validateSettings();", "    void storeSettings();", "    public void removeCurrentFile() {", "    public static List<String> split(String bibtexKeyPattern) {", "    public void indexEntry(BibEntry bibEntry) {", "                    if (type.getMimeType().startsWith(\"application/pdf\")) {", "                    notificationPane.show(validationMessage.getMessage());//this seems not working", "            return; // this should be impossible anyway", "    private void startExport() {", "    private static final String FILE_TYPE_REMOVED_FLAG = \"REMOVED\";", "        String styleSource = null;", "                List<FieldChange> undo = entryChanger.add(entries);", "        group.getGroupNode().removeEntriesFromGroup(stateManager.getSelectedEntries());", "    public static NativeDesktop getNativeDesktop() {", "               && !(getNode().getParent().get().getGroup() instanceof AllEntriesGroup);", "                return true;", "public class CustomJFXPanel {", "        var changes = groupNode.addEntriesToGroup(entries);", "        boolean canDropOtherGroup = dragboard.hasContent(DragAndDropDataFormats.GROUP);", "    public Optional<URL> findFullText(BibEntry entry) throws IOException {", "    public static BibDatabaseMode inferMode(BibDatabase database) {", "            updateAllTabTitles();", "            if (bf.getDatabase() != null) {", "            List<FieldComparator> fieldComparators = saveOrder.get()", "        int index = 0;", "    private static final Pattern REFERENCE_PATTERN = Pattern.compile(\"(#[A-Za-z]+#)\"); // Used to detect string references in strings", "    private PasteActionHandler pasteActionHandler = () -> {", "        warnBeforeOverwriting.setDisable(dontOverwrite.isSelected()));", "            ScrollPane scrollPane = new ScrollPane();", "                return getLastLevelBibtexKeyPattern(entryType);", "            if (!database.getPreamble().orElse(\"\").equals(newPreamble)) {", "                if (next > 0) {", "            Class<?> clazz = Class.forName(\"javafx.scene.control.TableUtil\");", "            content.put(DragAndDropDataFormats.LINKED_FILE, selectedItem);", "        fieldBinding = entry.getFieldBinding(field);", "                undoRemove.addEdit(UndoableChangeEntriesOfGroup.getUndoableEdit(this, changesAdd));", "@SuppressWarnings(\"unchecked\") public abstract class TreeNode<T extends TreeNode<T>> {", "    private void writeStrings(BibDatabase database) throws IOException {", "            writeMetaData(bibDatabaseContext.getMetaData(), preferences.getGlobalCiteKeyPattern());", "        writePreamble(bibDatabaseContext.getDatabase().getPreamble().orElse(\"\"));", "            exporter.export(panel.getBibDatabaseContext(), tmp,"]